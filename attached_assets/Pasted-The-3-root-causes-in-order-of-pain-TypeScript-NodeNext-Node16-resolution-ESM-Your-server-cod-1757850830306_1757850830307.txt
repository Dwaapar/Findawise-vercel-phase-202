The 3 root causes (in order of pain)
TypeScript “NodeNext/Node16” resolution + ESM
Your server code is compiled/bundled as ESM, but TS is checking with NodeNext/Node16 rules. That forces explicit file extensions in all relative imports. You’re missing them across hundreds of imports. → TS2835 everywhere. 
Path aliases not resolved
Imports like @shared/schema aren’t being resolved by TS (and likely not by esbuild either). → TS2307: Cannot find module '@shared/schema'. 
Missing symbols / bad type merges
Drizzle-like helpers (inArray, or, like) referenced but not imported.
Session type re-declared incorrectly (session augmentation clashes).
Several method/property name drifts (getNeuronHealthStatus vs getNeuronStatus; interface method signatures mismatched). 
Files that are currently breaking (from the log)
High-priority (stop-the-world)
server/index.ts – multiple TS2835 (missing .js extensions). 
server/routes.ts – the worst: 70+ TS2835, plus session type clash (TS2687/TS2717), and some logic flags “always truthy” (TS2872). 
server/vite.ts – Cannot find '../vite.config' (type-only? wrong path?). 
server/db.ts, server/db/index.ts, server/db/migrations.ts, server/db/db-health-monitor.ts – extensions missing, Supabase-type names referenced without imports (SupabaseClient, createClient), config flags not defined. 
server/storage.ts – massive: missing imports for inArray, or, like; unknown names (disasterRecoveryScenarios, culturalMappings, emotionProfiles, globalComplianceAuditSystem), interface method signature mismatch on updateConsent, missing method getUserSession. 

Also breaking
Any import using @shared/... (schema, localization, smartFunnelTables, storefrontTables, etc.). 
Feature routes (saas/finance/… many) all need explicit .js extensions in imports. 
Plan of attack (surgical, fastest path to a green build)
Step 0 — One config fix to kill hundreds of TS2835s (no code churn)
In tsconfig.server.json (or your server tsconfig):

Switch to Bundler resolution so TypeScript doesn’t require .js extensions for relative imports:

{
  "compilerOptions": {
    "module": "ESNext",
    "moduleResolution": "Bundler",
    "target": "ES2022",
    "lib": ["ES2022"],
    "verbatimModuleSyntax": true,
    "allowSyntheticDefaultImports": true,
    "skipLibCheck": true,
    "baseUrl": ".",
    "paths": {
      "@shared/*": ["shared/*"]
    }
  },
  "include": ["server", "shared"]
}


Why this matters: moduleResolution: "Bundler" makes TS follow esbuild/webpack-style resolution and stops TS2835 demanding .js suffixes during type-checking. That alone will erase the huge wall of extension errors. (Runtime is okay because you already bundle with esbuild.) 
If you prefer to keep NodeNext/Node16, we can mass-add .js to every relative import, but that’s a risky, time-consuming refactor. Bundler resolution is the pragmatic fix.
Step 1 — Make esbuild (and TS) understand @shared/*
Right now, TS can’t resolve @shared/schema, etc. Do both:
The paths mapping above (TS understands imports for type-check).
esbuild alias so the bundler resolves at runtime. Update your build script in package.json:

{
  "scripts": {
    "build": "vite build && esbuild server/index.ts --platform=node --packages=external --bundle --format=esm --outdir=dist --alias:@shared=./shared"
  }
}

esbuild supports --alias:name=path (recent versions). If your esbuild is older, you'll bump it or add a tiny build plugin. This prevents esbuild from treating @shared/* as an external package and ensures it bundles your local shared code.

Step 2 — Fix the session typing clash once
The log shows:
All declarations of 'session' must have identical modifiers

Property 'session' must be of type 'Session & Partial<SessionData>' … but you declared it as SessionData. 
Add a single augmentation file, e.g. server/types/session.d.ts:
import "express-session"
declare module "express-session" {
  interface SessionData {
    userId?: string
    // add other custom fields, optional!
    // quizState?: any
  }

  // If you extend Request, keep it consistent:
  // interface Session { ... } // ← usually don't redeclare Session itself
}


Make sure you do not redeclare session on Request in multiple places. If you already have one, you'll unify it into this single file and include server/types in tsconfig include.

Step 3 — Import the missing query helpers in server/storage.ts
Errors like Cannot find name 'inArray' | 'or' | 'like' → those are not in scope. Add at the top:
import { inArray, or, like } from "drizzle-orm" // or your ORM package where these come from
If you’re not using Drizzle, tell me your ORM so you point to the right package. The mistakes repeat across 5k+ lines; you'll place imports in the right file(s) once you upload server/storage.ts.
Also: getNeuronHealthStatus vs getNeuronStatus → either:
rename your calls to the actual method name, or
add a delegating method:

getNeuronHealthStatus(...args: Parameters<this["getNeuronStatus"]>) {
  return this.getNeuronStatus(...args)
}


you'll do the correct fix once you see the class definition.
